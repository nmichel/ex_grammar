# MP3 header parser (na√Øve)

## Section

```elixir
defmodule FrameSync do
  defstruct frame_sync: <<0xFF, 7::3>>

  def new, do: %__MODULE__{}
end

defimpl Grammar.Tokenizer.TokenExtractor, for: FrameSync do
  def try_read(_token_prototype, <<0xFF, 7::3, _rest::bitstring>>), do: {%FrameSync{}, 11}
  def try_read(_token_prototype, _input), do: nil

  def match?(%FrameSync{frame_sync: <<0xFF, 7::3>>}, %FrameSync{frame_sync: <<0xFF, 7::3>>}), do: true
  def match?(_token_prototype, _token), do: false
end

```

```elixir
defmodule AudioVersionID do
  defstruct [:id]

  def new, do: %__MODULE__{}

  def new(id) when id != 1 do
    %__MODULE__{id: id}
  end
end

defimpl Grammar.Tokenizer.TokenExtractor, for: AudioVersionID do
  def try_read(_token_prototype, <<0::1, 1::1, _rest::bitstring>>), do: nil
  def try_read(%AudioVersionID{id: nil}, <<id::size(2), _rest::bitstring>>), do: {AudioVersionID.new(id), 2}
  def try_read(%AudioVersionID{id: id}, <<id::size(2), _rest::bitstring>>), do: {AudioVersionID.new(id), 2}
  def try_read(_token_prototype, _input), do: nil

  def match?(%AudioVersionID{id: nil}, %AudioVersionID{}), do: true
  def match?(version, version), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
defmodule LayerDescription do
  defstruct [:id]

  def new, do: %__MODULE__{}

  def new(id) when id != 0 do
    %__MODULE__{id: id}
  end
end

defimpl Grammar.Tokenizer.TokenExtractor, for: LayerDescription do
  def try_read(_token_prototype, <<0::2, _rest::bitstring>>), do: nil
  def try_read(%LayerDescription{id: nil}, <<id::size(2), _rest::bitstring>>), do: {LayerDescription.new(id), 2}
  def try_read(%LayerDescription{id: id}, <<id::size(2), _rest::bitstring>>), do: {LayerDescription.new(id), 2}
  def try_read(_token_prototype, _input), do: nil

  def match?(%LayerDescription{id: nil}, %LayerDescription{}), do: true
  def match?(version, version), do: true
  def match?(_token_prototype, _token), do: false
end

# Forbidden
nil = Grammar.Tokenizer.TokenExtractor.try_read(LayerDescription.new(), <<0::2>>)

# Capture
{%{id: 2} , 2} = Grammar.Tokenizer.TokenExtractor.try_read(LayerDescription.new(), <<2::2>>)

# Match !
{%{id: 3} , 2} = Grammar.Tokenizer.TokenExtractor.try_read(LayerDescription.new(3), <<3::2>>)

# Match Error!
nil = Grammar.Tokenizer.TokenExtractor.try_read(LayerDescription.new(1), <<3::2>>)
```

```elixir
defmodule Protection do
  defstruct [:protected?]

  def new, do: %__MODULE__{}
  def new(protected?) when is_boolean(protected?), do: %__MODULE__{protected?: protected?}
end

defimpl Grammar.Tokenizer.TokenExtractor, for: Protection do
  def try_read(%Protection{protected?: nil}, <<bit::1, _rest::bitstring>>), do: {Protection.new(bit === 0b1), 1}
  def try_read(%Protection{protected?: true}, <<1::1, _rest::bitstring>>), do: {Protection.new(true), 1}
  def try_read(%Protection{protected?: false}, <<0::1, _rest::bitstring>>), do: {Protection.new(false), 1}
  def try_read(_token_prototype, _input), do: nil

  def match?(%Protection{protected?: nil}, %Protection{}), do: true
  def match?(%Protection{} = protection, protection), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
defmodule BitrateIndex do
  defstruct [:id]

  def new, do: %__MODULE__{}

  def new(id) when id != 1 do
    %__MODULE__{id: id}
  end
end

defimpl Grammar.Tokenizer.TokenExtractor, for: BitrateIndex do
  def try_read(_token_prototype, <<0xF::4, _rest::bitstring>>), do: nil
  def try_read(%BitrateIndex{id: nil}, <<id::size(4), _rest::bitstring>>), do: {BitrateIndex.new(id), 4}
  def try_read(%BitrateIndex{id: id}, <<id::size(4), _rest::bitstring>>), do: {BitrateIndex.new(id), 4}
  def try_read(_token_prototype, _input), do: nil

  def match?(%BitrateIndex{id: nil}, %BitrateIndex{}), do: true
  def match?(version, version), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
defmodule SamplingRateFreqIdx do
  defstruct [:id]

  def new, do: %__MODULE__{}

  def new(id) when id != 0b11 do
    %__MODULE__{id: id}
  end
end

defimpl Grammar.Tokenizer.TokenExtractor, for: SamplingRateFreqIdx do
  def try_read(_token_prototype, <<1::1, 1::1, _rest::bitstring>>), do: nil
  def try_read(%SamplingRateFreqIdx{id: nil}, <<id::size(2), _rest::bitstring>>), do: {SamplingRateFreqIdx.new(id), 2}
  def try_read(%SamplingRateFreqIdx{id: id}, <<id::size(2), _rest::bitstring>>), do: {SamplingRateFreqIdx.new(id), 2}
  def try_read(_token_prototype, _input), do: nil

  def match?(%SamplingRateFreqIdx{id: nil}, %SamplingRateFreqIdx{}), do: true
  def match?(version, version), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
defmodule Padding do
  defstruct [:padded?]

  def new, do: %__MODULE__{}
  def new(padded?) when is_boolean(padded?), do: %__MODULE__{padded?: padded?}
end

defimpl Grammar.Tokenizer.TokenExtractor, for: Padding do
  def try_read(%Padding{padded?: nil}, <<bit::1, _rest::bitstring>>), do: {Padding.new(bit === 0b1), 1}
  def try_read(%Padding{padded?: true}, <<1::1, _rest::bitstring>>), do: {Padding.new(true), 1}
  def try_read(%Padding{padded?: false}, <<0::1, _rest::bitstring>>), do: {Padding.new(false), 1}
  def try_read(_token_prototype, _input), do: nil

  def match?(%Padding{padded?: nil}, %Padding{}), do: true
  def match?(%Padding{} = protection, protection), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
defmodule Private do
  defstruct [:private?]

  def new, do: %__MODULE__{}
  def new(private?) when is_boolean(private?), do: %__MODULE__{private?: private?}
end

defimpl Grammar.Tokenizer.TokenExtractor, for: Private do
  def try_read(%Private{private?: nil}, <<bit::1, _rest::bitstring>>), do: {Private.new(bit === 0b1), 1}
  def try_read(%Private{private?: true}, <<1::1, _rest::bitstring>>), do: {Private.new(true), 1}
  def try_read(%Private{private?: false}, <<0::1, _rest::bitstring>>), do: {Private.new(false), 1}
  def try_read(_token_prototype, _input), do: nil

  def match?(%Private{private?: nil}, %Private{}), do: true
  def match?(%Private{} = protection, protection), do: true
  def match?(_token_prototype, _token), do: false
end
```

```elixir
test_header = <<
  0xFF::8, # Frame sync

  0x7::3, # Frame sync
  2::2, # MPEG Audio version ID
  1::2, # Layer description
  1::1, # Protection bit

  3::4, # Bitrate index
  1::2, # Sampling rate frequency index 
  0::1, # Padding bit
  1::1 # Private bit
>>
```

```elixir
Grammar.new()
|> Grammar.add_clause(:mp3_header, [
  FrameSync.new(),
  AudioVersionID.new(),
  LayerDescription.new(),
  Protection.new(),
  BitrateIndex.new(),
  SamplingRateFreqIdx.new(),
  Padding.new(),
  Private.new()
], fn [
  _magic,
  audio_id,
  layer_desc,
  protection,
  bitrate_idx,
  sampling_rf_idx,
  padding,
  private] ->
  %{
    audio_id: audio_id.id,
    layer_desc: layer_desc.id,
    protection?: protection.protected?,
    bitrate_idx: bitrate_idx.id,
    sampling_rf_idx: sampling_rf_idx.id,
    padding?: padding.padded?,
    private: private.private?
  }
end)
|> Grammar.prepare!()
|> Grammar.start(:mp3_header)
|> Grammar.loop(Grammar.Tokenizer.new(test_header, false, true))
```
